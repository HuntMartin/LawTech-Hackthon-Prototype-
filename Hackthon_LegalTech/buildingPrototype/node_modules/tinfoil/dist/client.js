"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TinfoilAI = void 0;
const openai_1 = __importDefault(require("openai"));
const crypto_1 = require("crypto");
const secure_client_1 = require("./secure-client");
const https_1 = __importDefault(require("https"));
const config_1 = require("./config");
/**
 * Creates a proxy that allows property access and method calls on a Promise before it resolves.
 * This enables a more ergonomic API where you can chain properties and methods without explicitly
 * awaiting the promise first.
 *
 * @param promise - A Promise that will resolve to an object
 * @returns A proxied version of the promised object that allows immediate property/method access
 *
 * @example
 * // Instead of:
 * const client = await getClient();
 * const result = await client.someProperty.someMethod();
 *
 * // You can write:
 * const client = createAsyncProxy(getClient());
 * const result = await client.someProperty.someMethod();
 *
 * @template T - The type of object that the promise resolves to
 */
function createAsyncProxy(promise) {
    return new Proxy({}, {
        get(target, prop) {
            return new Proxy(() => { }, {
                get(_, nestedProp) {
                    return (...args) => promise.then(obj => {
                        const value = obj[prop][nestedProp];
                        return typeof value === 'function' ? value.apply(obj[prop], args) : value;
                    });
                },
                apply(_, __, args) {
                    return promise.then(obj => {
                        const value = obj[prop];
                        return typeof value === 'function' ? value.apply(obj, args) : value;
                    });
                }
            });
        }
    });
}
class TinfoilAI {
    /**
     * Creates a new TinfoilAI instance.
     * @param options - Configuration options including apiKey and other OpenAI client options
     */
    constructor(options = {}) {
        // Set apiKey from options or environment variable
        const openAIOptions = { ...options };
        if (options.apiKey || process.env.TINFOIL_API_KEY) {
            openAIOptions.apiKey = options.apiKey || process.env.TINFOIL_API_KEY;
        }
        this.clientPromise = this.initClient(openAIOptions);
    }
    /**
     * Ensures the client is ready to use.
     * @returns Promise that resolves when the client is initialized
     */
    async ready() {
        if (!this.readyPromise) {
            this.readyPromise = (async () => {
                this.client = await this.clientPromise;
            })();
        }
        return this.readyPromise;
    }
    async initClient(options) {
        return this.createOpenAIClient(options);
    }
    async createOpenAIClient(options = {}) {
        // Verify the enclave and get the certificate fingerprint
        const secureClient = new secure_client_1.SecureClient();
        try {
            this.groundTruth = await secureClient.verify();
        }
        catch (error) {
            throw new Error(`Failed to verify enclave: ${error}`);
        }
        const expectedFingerprint = this.groundTruth.publicKeyFP;
        // Create a custom HTTPS agent that verifies certificate fingerprints
        const httpsAgent = new https_1.default.Agent({
            rejectUnauthorized: true,
            checkServerIdentity: (host, cert) => {
                if (!cert || !cert.raw) {
                    throw new Error('No certificate found');
                }
                if (!cert.pubkey) {
                    throw new Error('No public key found');
                }
                const pemCert = `-----BEGIN CERTIFICATE-----\n${cert.raw.toString('base64')}\n-----END CERTIFICATE-----`;
                const x509Cert = new crypto_1.X509Certificate(pemCert);
                const publicKey = x509Cert.publicKey.export({ format: 'der', type: 'spki' });
                const publicKeyHash = (0, crypto_1.createHash)('sha256').update(publicKey).digest('hex');
                if (publicKeyHash !== expectedFingerprint) {
                    throw new Error(`Certificate fingerprint mismatch. Got ${publicKeyHash}, expected ${expectedFingerprint}`);
                }
                return undefined; // Validation successful
            }
        });
        // Create the OpenAI client with our custom configuration
        // Note: baseURL will need to be determined by the verification process
        return new openai_1.default({
            ...options,
            baseURL: config_1.TINFOIL_CONFIG.INFERENCE_BASE_URL,
        });
    }
    /**
     * Helper method to ensure the OpenAI client is initialized before use.
     * Automatically calls ready() if needed.
     * @returns The initialized OpenAI client
     * @private
     */
    async ensureReady() {
        await this.ready();
        // We can safely assert this now because ready() must have completed
        return this.client;
    }
    /**
     * Access to OpenAI's chat completions API for creating chat conversations.
     * Automatically initializes the client if needed.
     */
    get chat() {
        return createAsyncProxy(this.ensureReady().then(client => client.chat));
    }
    /**
     * Access to OpenAI's files API for managing files used with the API.
     * Automatically initializes the client if needed.
     */
    get files() {
        return createAsyncProxy(this.ensureReady().then(client => client.files));
    }
    /**
     * Access to OpenAI's fine-tuning API for creating and managing fine-tuned models.
     * Automatically initializes the client if needed.
     */
    get fineTuning() {
        return createAsyncProxy(this.ensureReady().then(client => client.fineTuning));
    }
    /**
     * Access to OpenAI's image generation and editing API.
     * Automatically initializes the client if needed.
     */
    get images() {
        return createAsyncProxy(this.ensureReady().then(client => client.images));
    }
    /**
     * Access to OpenAI's audio API for speech-to-text and text-to-speech.
     * Automatically initializes the client if needed.
     */
    get audio() {
        return createAsyncProxy(this.ensureReady().then(client => client.audio));
    }
    /**
     * Access to OpenAI's embeddings API for creating vector embeddings of text.
     * Automatically initializes the client if needed.
     */
    get embeddings() {
        return createAsyncProxy(this.ensureReady().then(client => client.embeddings));
    }
    /**
     * Access to OpenAI's models API for listing and managing available models.
     * Automatically initializes the client if needed.
     */
    get models() {
        return createAsyncProxy(this.ensureReady().then(client => client.models));
    }
    /**
     * Access to OpenAI's content moderation API.
     * Automatically initializes the client if needed.
     */
    get moderations() {
        return createAsyncProxy(this.ensureReady().then(client => client.moderations));
    }
    /**
     * Access to OpenAI's beta features.
     * Automatically initializes the client if needed.
     */
    get beta() {
        return createAsyncProxy(this.ensureReady().then(client => client.beta));
    }
}
exports.TinfoilAI = TinfoilAI;
