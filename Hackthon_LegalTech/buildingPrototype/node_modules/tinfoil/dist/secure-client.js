"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecureClient = void 0;
const node_fetch_1 = __importDefault(require("node-fetch"));
const util_1 = require("util");
const config_1 = require("./config");
// Set up browser-like globals that the Go WASM runtime expects
const globalThis = global;
// Performance API
globalThis.performance = {
    now: () => Date.now(),
    markResourceTiming: () => {
    },
    mark: () => {
    },
    measure: () => {
    },
    clearMarks: () => {
    },
    clearMeasures: () => {
    },
    getEntriesByName: () => [],
    getEntriesByType: () => [],
    getEntries: () => []
};
// Text encoding
globalThis.TextEncoder = util_1.TextEncoder;
globalThis.TextDecoder = util_1.TextDecoder;
// Crypto API (needed by Go WASM)
if (!globalThis.crypto) {
    globalThis.crypto = {
        getRandomValues: (buffer) => {
            const randomBytes = require('crypto').randomBytes(buffer.length);
            buffer.set(new Uint8Array(randomBytes));
            return buffer;
        }
    };
}
// Modified secure-client.ts
if (typeof window === 'undefined') {
    // Node.js environment
    globalThis.window = globalThis;
    globalThis.document = {
        createElement: () => ({
            setAttribute: () => {
            }
        })
    };
}
// Force process to stay running (prevent Go from exiting Node process)
// This is a common issue with Go WASM in Node - it calls process.exit()
const originalExit = process.exit;
process.exit = ((code) => {
    console.log(`Process exit called with code ${code} - ignoring to keep Node.js process alive`);
    return undefined;
});
// Load the Go runtime helper
require('./wasm-exec.js');
/**
 * SecureClient handles verification of code and runtime measurements using WebAssembly
 */
class SecureClient {
    constructor() {
        // Values for the Tinfoil inference proxy from config
        this.enclave = new URL(config_1.TINFOIL_CONFIG.INFERENCE_BASE_URL).hostname;
        this.repo = config_1.TINFOIL_CONFIG.INFERENCE_PROXY_REPO;
    }
    /**
     * Static method to initialize WASM module
     * This starts automatically when the class is loaded
     */
    static async initializeWasm() {
        if (SecureClient.initializationPromise) {
            return SecureClient.initializationPromise;
        }
        SecureClient.initializationPromise = (async () => {
            try {
                SecureClient.goInstance = new globalThis.Go();
                const wasmResponse = await (0, node_fetch_1.default)('https://tinfoilsh.github.io/verifier-js/tinfoil-verifier.wasm');
                const wasmBuffer = await wasmResponse.arrayBuffer();
                const result = await WebAssembly.instantiate(wasmBuffer, SecureClient.goInstance.importObject);
                const runPromise = SecureClient.goInstance.run(result.instance);
                let attempts = 0;
                const maxAttempts = 10;
                while (attempts < maxAttempts) {
                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 100));
                    const hasVerifyCode = typeof globalThis.verifyCode === 'function';
                    const hasVerifyEnclave = typeof globalThis.verifyEnclave === 'function';
                    if (hasVerifyCode && hasVerifyEnclave) {
                        return;
                    }
                }
                throw new Error('WASM functions not exposed after multiple attempts');
            }
            catch (error) {
                console.error('WASM initialization error:', error);
                throw error;
            }
        })();
        return SecureClient.initializationPromise;
    }
    /**
     * Initialize the WASM module
     * Now just waits for the static initialization to complete
     */
    async initialize() {
        await SecureClient.initializeWasm();
    }
    /**
     * Verifies the integrity of both the code and runtime environment
     */
    async verify() {
        await this.initialize();
        try {
            if (typeof globalThis.verifyCode !== 'function' || typeof globalThis.verifyEnclave !== 'function') {
                throw new Error('WASM functions not available');
            }
            const releaseResponse = await (0, node_fetch_1.default)(`https://api.github.com/repos/${this.repo}/releases/latest`, {
                headers: {
                    'Accept': 'application/vnd.github.v3+json',
                    'User-Agent': 'tinfoil-node-client'
                }
            });
            if (!releaseResponse.ok) {
                throw new Error(`GitHub API request failed: ${releaseResponse.status} ${releaseResponse.statusText}`);
            }
            const releaseData = await releaseResponse.json();
            const eifRegex = /EIF hash: ([a-f0-9]{64})/i;
            const digestRegex = /Digest: `([a-f0-9]{64})`/;
            let digest;
            const eifMatch = releaseData.body?.match(eifRegex);
            const digestMatch = releaseData.body?.match(digestRegex);
            if (eifMatch) {
                digest = eifMatch[1];
            }
            else if (digestMatch) {
                digest = digestMatch[1];
            }
            else {
                throw new Error('Could not find digest in release notes');
            }
            const [measurement, attestationResponse] = await Promise.all([
                globalThis.verifyCode(this.repo, digest),
                globalThis.verifyEnclave(this.enclave)
            ]);
            if (measurement !== attestationResponse.measurement) {
                throw new Error('Measurements do not match');
            }
            return {
                publicKeyFP: attestationResponse.certificate,
                measurement: attestationResponse.measurement,
            };
        }
        catch (error) {
            throw error;
        }
    }
}
exports.SecureClient = SecureClient;
SecureClient.goInstance = null;
SecureClient.initializationPromise = null;
// Start initialization as soon as the module loads
SecureClient.initializeWasm().catch(console.error);
